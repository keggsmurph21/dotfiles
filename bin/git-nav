#!/bin/bash
#
# Kevin Murphy
# 2/11/2020


set -euo pipefail


NAV_DIR="$(git dir)/.wt/nav-history"
CURRENT="$NAV_DIR/current"
BACK_STACK="$NAV_DIR/back"
FW_STACK="$NAV_DIR/fw"
INTERNAL_FLAG="$NAV_DIR/.internal"


__git_nav_usage() {
    cat <<USAGE >&2
usage: $ git-nav [ back | clear | install | fw | show | where ]

    Keep track of recently-checked out branches of a git repository.

    This script is meant to be used by both humans and by the git "post-checkout"
    hook.  Whenever you check out a new ref, git will call this script, allowing
    us to track some state.

    In order to start using it in any repository, just

        $ git-nav install

USAGE
}


__git_nav_init() {
    if [ ! -d "$NAV_DIR" ]; then
        mkdir -p "$NAV_DIR"
        touch "$BACK_STACK" "$FW_STACK"
        __git_nav_ref_name > "$CURRENT"
    fi
}


__git_nav_install() {
    this_script="$DOTFILES_DIR/bin/git-nav"
    hook_script="$(git root)/.git/hooks/post-checkout"
    if [ ! -f "$hook_script" ]; then
        ln -s "$this_script" "$hook_script"
    elif [ "$(readlink "$hook_script")" != "$this_script" ]; then
        echo "There is already a post-checkout script!  History won't be saved." >&2
    fi
}


__git_nav_ref_name() {
    # FIXME: Is there better heuristic we should use here?
    local ref_name="$(git bname)"
    if [[ "$ref_name" == HEAD ]]; then
        ref_name="$1"
    fi
    echo "$ref_name"
}


__git_nav_on_post_checkout_hook() {
    #
    # git post-checkout hook entry point
    #
    # Note: This script is called by git with three arguments:
    #   1)  the ref of the previous HEAD
    #   2)  the ref of the current HEAD
    #   3)  0 if checking-out a file, 1 if checking-out a branch
    #
    # See https://git-scm.com/docs/githooks#_post_checkout for more info.

    if [[ "$3" -eq 0 ]]; then
        # This was to checkout a single file
        exit 0
    fi

    if [ -f "$INTERNAL_FLAG" ]; then
        # This was generated by git-nav
        exit 0
    fi

    local current_ref_name stored_ref_name
    current_ref_name="$(__git_nav_ref_name)"
    stored_ref_name="$(cat "$CURRENT")"
    if [[ "$current_ref_name" != "$stored_ref_name" ]]; then
        echo "$stored_ref_name" >> "$BACK_STACK"
        echo "$current_ref_name" > "$CURRENT"
    fi
    truncate -s0 "$FW_STACK"
}


__git_nav_safe_checkout() {
    local pop_from source push_to target
    pop_from="$1"
    push_to="$2"
    source="$(cat "$CURRENT")"
    while [ -s "$pop_from" ]; do
        target="$(tail -n1 "$pop_from")"
        sed -i'' -E '$ d' "$pop_from"
        touch "$INTERNAL_FLAG"
        if git checkout "$target"; then
            rm "$INTERNAL_FLAG"
            echo "$source" >> "$push_to"
            echo "$target" > "$CURRENT"
            return 0
        fi
        echo "git-nav: Cannot find ref $target, skipping ..." >&2
    done
    return 1
}


__git_nav_back() {
    __git_nav_safe_checkout "$BACK_STACK" "$FW_STACK" \
        || echo "git-nav: Cannot go back any farther!" >&2
}


__git_nav_fw() {
    __git_nav_safe_checkout "$FW_STACK" "$BACK_STACK" \
        || echo "cannot go forward any farther!" >&2
}


__git_nav_show() {
    cat "$BACK_STACK" | sed -E 's/^/  /'
    echo "* $(cat "$CURRENT")"
    tac "$FW_STACK" | sed -E 's/^/  /'
}


__git_nav_clear() {
    __git_nav_show >&2
    if confirm "Are you sure you want to delete your checkout history? [y/n] "; then
        rm -rf "$NAV_DIR"
    fi
}


__git_nav_main() {
    case "$1" in
        back)   __git_nav_back ;;
        clear)  __git_nav_clear ;;
        install)__git_nav_install ;;
        fw)     __git_nav_fw ;;
        show)   __git_nav_show ;;
        where)  echo "$NAV_DIR" ;;
        *)      usage ;;
    esac
}


__git_nav_init


if [[ $# -eq 3 ]]; then
    __git_nav_on_post_checkout_hook "$@"
else
    __git_nav_main "$@"
fi
